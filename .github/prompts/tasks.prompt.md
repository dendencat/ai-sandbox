# Break down the plan into executable tasks

計画を実行可能なタスクに分解してください。

これはSpec-Driven Developmentライフサイクルの3番目のステップです。

引数として提供されたコンテキストを基に、以下のことを行ってください：

1. リポジトリのルートから `scripts/check-task-prerequisites.sh --json` を実行し、FEATURE_DIR と AVAILABLE_DOCS リストを解析します。すべてのパスは絶対パスである必要があります。
2. 利用可能な設計ドキュメントを読み込んで分析します：
   - 常に plan.md を読み込んで技術スタックとライブラリを確認します
   - 存在する場合：data-model.md を読み込んでエンティティを確認します
   - 存在する場合：contracts/ を読み込んでAPIエンドポイントを確認します  
   - 存在する場合：research.md を読み込んで技術的な決定を確認します
   - 存在する場合：quickstart.md を読み込んでテストシナリオを確認します
   
   注意：すべてのプロジェクトがすべてのドキュメントを持っているわけではありません。例えば：
   - CLIツールは contracts/ を持たない場合があります
   - シンプルなライブラリは data-model.md を必要としない場合があります
   - 利用可能なものに基づいてタスクを生成してください

3. テンプレートに従ってタスクを生成します：
   - `/templates/tasks-template.md` をベースとして使用します
   - 以下の内容に基づいてサンプルタスクを実際のタスクに置き換えます：
     * **セットアップタスク**：プロジェクト初期化、依存関係、リンティング
     * **テストタスク [P]**：各コントラクトごとに1つ、各統合シナリオごとに1つ
     * **コアタスク**：各エンティティ、サービス、CLIコマンド、エンドポイントごとに1つ
     * **統合タスク**：DB接続、ミドルウェア、ロギング
     * **仕上げタスク [P]**：ユニットテスト、パフォーマンス、ドキュメント

4. タスク生成ルール：
   - 各コントラクトファイル → [P] マーク付きのコントラクトテストタスク
   - data-model の各エンティティ → [P] マーク付きのモデル作成タスク
   - 各エンドポイント → 実装タスク（共有ファイルの場合は並列不可）
   - 各ユーザーストーリー → [P] マーク付きの統合テスト
   - 異なるファイル = 並列可能 [P]
   - 同じファイル = 順次（[P] なし）

5. 依存関係によってタスクを順序付けします：
   - セットアップをすべてより先に
   - テストを実装より先に（TDD）
   - モデルをサービスより先に
   - サービスをエンドポイントより先に
   - コアを統合より先に
   - すべてを仕上げより先に

6. 並列実行の例を含めます：
   - 同時に実行可能な [P] タスクをグループ化
   - 実際のTaskエージェントコマンドを表示

7. FEATURE_DIR/tasks.md を作成します：
   - 実装計画から正しい機能名を使用
   - 番号付きタスク（T001, T002, など）
   - 各タスクの明確なファイルパス
   - 依存関係の注記
   - 並列実行のガイダンス

タスク生成のコンテキスト：$ARGUMENTS

tasks.md は即時実行可能である必要があります。各タスクは、LLMが追加のコンテキストなしで完了できるほど具体的である必要があります。

